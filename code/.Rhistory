for(j in 1:ncol(correlation_matrix)){
if(j < i){
correlation_matrix[i,j] <- correlation_matrix[j,i]
}
}
}
# Convert correlations into distances.
dist_matrix <- as.dist(1 - correlation_matrix)
cluster <- hclust(dist_matrix, method = 'complete')
dendrogram <- as.dendrogram(cluster)
# Within topological constraints of dendrogram, tries to order mice with day 8 on top, then day 16,
#etc.
leaf_weights <- 1/as.integer(str_extract(cluster$labels, '[0-9]+'))
dendrogram <- reorder(dendrogram,
wts = leaf_weights)
annotation <- get_info_from_mouse_id(
tibble(mouse_id = cluster$labels)
)
dendro_heatmap <- heatmaply(x = correlation_matrix,
scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
low = "blue",
high = "red",
midpoint = 0,
limits = c(-1, 1)
),
Rowv = dendrogram,
Colv = dendrogram,
row_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
col_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
seriate = 'none',
key.title = 'Spearman correlation\nin V gene frequencies')
return(dendro_heatmap)
}
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'PC',
tissue = 'LN')
# Clustering based on Spearman correlation of V gene frequencies as an inverse measure of distance.
get_vgene_freq_correlation_clustering <- function(pairwise_correlations, cell_type, tissue, metric){
if(metric == 'freqs'){
data_subset <- pairwise_correlations$freqs %>%
rename(cor_coef = cor_coef_freqs)
color_key_title <- 'Spearman correlation\nin V gene frequencies'
}else{
stopifnot(metric == 'freq_ratios')
data_subset <- pairwise_correlations$freq_ratios %>%
rename(cor_coef = cor_coef_freq_ratios)
color_key_title <- 'Spearman correlation\nin V gene frequency deviations from\nnaive repertoire\n'
}
data_subset <- data_subset %>%
filter(total_compartment_seqs_i >= 100, total_compartment_seqs_j >= 100) %>%
filter(cell_type == !!cell_type, tissue == !!tissue) %>%
select(mouse_id_i, mouse_id_j, cor_coef)
# Add a diagonal to the correlation matrix (each mouse has correlation 1 with itself)
data_subset <- bind_rows(data_subset,
tibble(mouse_id_i = unique(c(data_subset$mouse_id_i, data_subset$mouse_id_j))) %>%
mutate(mouse_id_j = mouse_id_i, cor_coef = 1)) %>%
arrange(mouse_id_i, mouse_id_j)
wide_format_correlations <- data_subset %>%
pivot_wider(names_from = mouse_id_j, values_from = cor_coef)
correlation_matrix <- as.matrix(wide_format_correlations[colnames(wide_format_correlations) != 'mouse_id_i'])
rownames(correlation_matrix) <- wide_format_correlations$mouse_id_i
# Fill lower triangle
for(i in 1:nrow(correlation_matrix)){
for(j in 1:ncol(correlation_matrix)){
if(j < i){
correlation_matrix[i,j] <- correlation_matrix[j,i]
}
}
}
# Convert correlations into distances.
dist_matrix <- as.dist(1 - correlation_matrix)
cluster <- hclust(dist_matrix, method = 'complete')
dendrogram <- as.dendrogram(cluster)
# Within topological constraints of dendrogram, tries to order mice with day 8 on top, then day 16,
#etc.
leaf_weights <- 1/as.integer(str_extract(cluster$labels, '[0-9]+'))
dendrogram <- reorder(dendrogram,
wts = leaf_weights)
annotation <- get_info_from_mouse_id(
tibble(mouse_id = cluster$labels)
)
dendro_heatmap <- heatmaply(x = correlation_matrix,
scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
low = "blue",
high = "red",
midpoint = 0,
limits = c(-1, 1)
),
Rowv = dendrogram,
Colv = dendrogram,
row_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
col_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
seriate = 'none',
key.title = color_key_title)
return(dendro_heatmap)
}
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'PC',
tissue = 'LN')
# Clustering based on Spearman correlation of V gene frequencies as an inverse measure of distance.
get_vgene_freq_correlation_clustering <- function(pairwise_correlations, cell_type, tissue, metric){
if(metric == 'freqs'){
data_subset <- pairwise_correlations$freqs %>%
rename(cor_coef = cor_coef_freqs)
color_key_title <- 'Spearman correlation\nin V gene frequencies'
}else{
stopifnot(metric == 'freq_ratios')
data_subset <- pairwise_correlations$freq_ratios %>%
rename(cor_coef = cor_coef_freq_ratios)
color_key_title <- 'Spearman correlation\nin V gene frequency deviations\nfrom the naive repertoire\n'
}
data_subset <- data_subset %>%
filter(total_compartment_seqs_i >= 100, total_compartment_seqs_j >= 100) %>%
filter(cell_type == !!cell_type, tissue == !!tissue) %>%
select(mouse_id_i, mouse_id_j, cor_coef)
# Add a diagonal to the correlation matrix (each mouse has correlation 1 with itself)
data_subset <- bind_rows(data_subset,
tibble(mouse_id_i = unique(c(data_subset$mouse_id_i, data_subset$mouse_id_j))) %>%
mutate(mouse_id_j = mouse_id_i, cor_coef = 1)) %>%
arrange(mouse_id_i, mouse_id_j)
wide_format_correlations <- data_subset %>%
pivot_wider(names_from = mouse_id_j, values_from = cor_coef)
correlation_matrix <- as.matrix(wide_format_correlations[colnames(wide_format_correlations) != 'mouse_id_i'])
rownames(correlation_matrix) <- wide_format_correlations$mouse_id_i
# Fill lower triangle
for(i in 1:nrow(correlation_matrix)){
for(j in 1:ncol(correlation_matrix)){
if(j < i){
correlation_matrix[i,j] <- correlation_matrix[j,i]
}
}
}
# Convert correlations into distances.
dist_matrix <- as.dist(1 - correlation_matrix)
cluster <- hclust(dist_matrix, method = 'complete')
dendrogram <- as.dendrogram(cluster)
# Within topological constraints of dendrogram, tries to order mice with day 8 on top, then day 16,
#etc.
leaf_weights <- 1/as.integer(str_extract(cluster$labels, '[0-9]+'))
dendrogram <- reorder(dendrogram,
wts = leaf_weights)
annotation <- get_info_from_mouse_id(
tibble(mouse_id = cluster$labels)
)
dendro_heatmap <- heatmaply(x = correlation_matrix,
scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
low = "blue",
high = "red",
midpoint = 0,
limits = c(-1, 1)
),
Rowv = dendrogram,
Colv = dendrogram,
row_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
col_side_colors = annotation %>% select(group_controls_pooled) %>%
rename(group = group_controls_pooled),
seriate = 'none',
key.title = color_key_title)
return(dendro_heatmap)
}
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'PC',
tissue = 'LN')
# ----- Dendrograms and heatmaps based on correlation in V gene frequency deviations from naive repertoire -------
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'PC',
tissue = 'LN')
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'GC',
tissue = 'LN')
get_vgene_freq_correlation_clustering(pairwise_correlations = pairwise_correlations,
metric = 'freq_ratios',
cell_type = 'mem',
tissue = 'LN')
setwd("/Volumes/cobey/mvieira/v_gene_selection/code")
yaml_file_path <- '../results/partis/PSC02F_HC.yaml'
library(dplyr)
library(tidyr)
library(yaml)
library(stringr)
library(msa)
library(seqinr)
library(Biostrings)
source('imgt_region_bounds.R')
setwd("/Volumes/cobey/mvieira/psc_repertoire/code")
library(dplyr)
library(tidyr)
library(yaml)
library(stringr)
library(msa)
library(seqinr)
library(Biostrings)
source('imgt_region_bounds.R')
igblast_annotation_path = "../results/partis/PSC02F_HC_igblast_db-pass.tab"
isotype_info_path <- NULL
# Creates tibble linking duplicated sequences to those chosen as the representative sequence
pair_duplicates <- function(clone){
duplicate_seqs <- c()
for(i in 1:length(clone$duplicates)){
representative_seq = clone$unique_ids[i]
duplicates <- clone$duplicates[[i]]
if(length(duplicates) > 0){
duplicate_seqs <- bind_rows(duplicate_seqs,
tibble(duplicate_seq = duplicates, representative_seq))
}
}
return(duplicate_seqs)
}
convert_position_range <- function(ungapped_seq, gapped_seq, ungapped_range){
ungapped_seq = strsplit(ungapped_seq, '')[[1]]
gapped_seq = strsplit(gapped_seq, '')[[1]]
adjusted_range = ungapped_range
n_gaps = 0
for(i in 1:length(gapped_seq)){
if((gapped_seq[i]) %in% c('-','.')){
n_gaps <- n_gaps + 1
position_in_ungapped_seq = i - n_gaps
# If gap occurs before the start of the range in the ungapped seq, entire range is pushed by 1
if(position_in_ungapped_seq <  ungapped_range[1]){
adjusted_range <- adjusted_range + 1
}
# If gap is within the range in the ungapped seq, end of range is pushed by 1
if(position_in_ungapped_seq >=  ungapped_range[1] & position_in_ungapped_seq < ungapped_range[2]){
adjusted_range[2] <- adjusted_range[2] + 1
}
}
}
return(adjusted_range)
}
# Some tests for the conversion function, including cases with gaps at either end of range
stopifnot(all(convert_position_range('AACTAAAG','A-ACTAA-AG',c(5,7)) == c(6,9)))
stopifnot(all(convert_position_range('AACTAAAG','AACTAAAG---',c(5,7)) == c(5,7)))
stopifnot(all(convert_position_range('AACTAAAG','AACTA-AAG',c(5,7)) == c(5,8)))
stopifnot(all(convert_position_range('AACTAAAG','AACT-AAAG',c(5,7)) == c(6,8)))
stopifnot(all(convert_position_range('AACTAAAG','AACTAAA-G',c(5,7)) == c(5,7)))
stopifnot(all(convert_position_range('AACTAAAG','A-ACTAAAG',c(5,7)) == c(6,8)))
# Pulls sequence of a FR or CDR from a matrix-object alignment
pull_region_seq <- function(aln, imgt_region_bounds, region){
start <- imgt_region_bounds %>% filter(region == !!region) %>% pull(start)
end <- imgt_region_bounds %>% filter(region == !!region) %>% pull(end)
if(nrow(aln) > 1){
seqs <- apply(aln[, start:end], 1, FUN = paste, collapse = '')
}else{
seqs <- paste(aln[, start:end], collapse = '')
}
return(seqs)
}
# Given a character vector of aligned sequences, removes sites that are all gaps
# Can be used to remove sites that are all 'N' if gap_character set to 'N'
remove_allgap_sites <- function(seqs, gap_character = '-'){
if(length(seqs) >1){
seqmatrix <- c()
for(s in seqs){
seqmatrix <- rbind(seqmatrix, str_split(s,'')[[1]])
}
rownames(seqmatrix) <- names(seqs)
allgap_sites <- apply(seqmatrix, 2, FUN = function(x){return(all(x == gap_character))})
seqmatrix <- seqmatrix[,allgap_sites == F]
adjusted_seqs <- apply(seqmatrix,1,paste,collapse ='')
}else{
adjusted_seqs <- str_remove_all(seqs, gap_character)
}
return(adjusted_seqs)
}
stopifnot(remove_allgap_sites(c('--AAA','---BB')) == c("AAA", "-BB"))
stopifnot(remove_allgap_sites(c('NNAAA','NNNBB'), gap_character = 'N') == c("AAA", "NBB"))
# Gets number of uniq seqs, v/d/j, n uniqu igg seqs. Also returns vector of seqs (incl. germline) with Ns removed
get_basic_clone_info <- function(clone, isotype_info = NULL){
clone_info <- tibble(n_seqs = length(clone$unique_ids) +
sum(sapply(clone$duplicates, FUN = length)),
n_unique_seqs =  length(clone$unique_ids),
v_gene = clone$v_gene, d_gene = clone$d_gene, j_gene = clone$j_gene)
clone_seqs <- tibble(seq_id = clone$unique_ids, in_frame = clone$in_frames, has_stop_codon = clone$stops,
key_residues_conserved = !clone$mutated_invariants, seq = clone$input_seqs,
cdr3_seq = clone$cdr3_seqs)
if(!is.null(isotype_info)){
clone_seqs <- left_join(clone_seqs, isotype_info %>% mutate(seq_id = Name, isotype = Isotype) %>%
select(seq_id, isotype))
n_unique_igg <- length(clone_seqs %>% filter(grepl('IgG', isotype)) %>% pull(seq_id))
n_unique_iga <- length(clone_seqs %>% filter(grepl('IgA', isotype)) %>% pull(seq_id))
clone_info <- clone_info %>% mutate(n_unique_igg, n_unique_iga) %>%
select(n_seqs, n_unique_seqs, n_unique_igg, n_unique_iga, everything())
}
# Make duplicate sequences explicit
duplicates <- pair_duplicates(clone)
if(is.null(duplicates) == F){
duplicates <- left_join(duplicates %>% dplyr::rename(seq_id = representative_seq), clone_seqs) %>%
select(-seq_id) %>%
dplyr::rename(seq_id = duplicate_seq)
clone_seqs <- bind_rows(clone_seqs, duplicates)
}
clone_seqs <- clone_seqs %>%
mutate(is_productive = (has_stop_codon == F)&(in_frame)&(key_residues_conserved == T))
# Remove 'N' characters introduced by partis for sites outside of VDJ region
clone_seqs <- clone_seqs %>%
mutate(seq = str_replace_all(seq,'N',''))
# Get Naive seq
cdr3_start <- clone$codon_positions$v + 1 # Adds one because partis numbering starts at 0
cdr3_end <- clone$codon_positions$j + 3 # adds +1 and then +2 to go to end of codon
naive_cdr3_seq <- str_sub(clone$naive_seq, cdr3_start, cdr3_end)
naive_seq = str_replace_all(clone$naive_seq, 'N','')
# Output vectors
# (Adding a value T at the beginning representing naive sequence)
is_productive <- c(T, clone_seqs$is_productive)
clone_cdr3_seqs <- c(naive_cdr3_seq, clone_seqs$cdr3_seq)
names(clone_cdr3_seqs) <- c('NAIVE', clone_seqs$seq_id)
clone_seqs <- c(naive_seq, clone_seqs$seq)
names(clone_seqs) <- names(clone_cdr3_seqs)
return(list('info' = clone_info, 'seqs' = clone_seqs, 'cdr3_seqs' = clone_cdr3_seqs, 'is_productive' = is_productive))
}
# Replaces codons containing a gap with 'NNN'
mask_gapped_codons <- function(seqs){
mask_function <- function(s){
masked_s <- ''
n_codon_sites <- ceiling(nchar(s)/3)
codon_start_positions <- c(1, (2:n_codon_sites)*3 - 2)
for(codon_start in codon_start_positions){
# If sequence ends before codon is complete
if(codon_start + 2 > nchar(s)){
codon <- 'NNN'
}else{
codon <- substr(s, codon_start , codon_start +2)
if(grepl('-',codon)){
codon <- 'NNN'
}
}
masked_s <- paste0(masked_s, codon)
}
return(masked_s)
}
# Apply internal function to all sequences
masked_seqs <- sapply(as.list(seqs), FUN = mask_function)
# If a sequence is shorter than the others, fill difference with masked codons
max_seq_length = max(nchar(masked_seqs))
for(i in 1:length(masked_seqs)){
if(nchar(masked_seqs[i]) < max_seq_length){
stopifnot((max_seq_length - nchar(masked_seqs[i])) %% 3 == 0)
masked_seqs[i] <- paste(c(masked_seqs[i], rep('N', max_seq_length - nchar(masked_seqs[i]))), collapse = '')
}
}
names(masked_seqs) <- names(seqs)
return(masked_seqs)
}
# Given a character vector of aligned sequences, returns whether each has a stop codon
check_stop_codons <- function(seqs){
# Replace gaps with 'Ns' for translation
seqs <- str_replace_all(seqs, '-','N')
has_stop_codons <- as.character(Biostrings::translate(DNAStringSet(seqs),
if.fuzzy.codon = 'solve'))
has_stop_codons <- grepl('\\*', has_stop_codons)
return(has_stop_codons)
}
stopifnot(check_stop_codons(c('AAAGGG','TAGAAG','TT----')) == c(F,T,F))
output_dir = '../results/partis/'
yaml_object <- read_yaml(yaml_file_path)
igblast_annotation <- as_tibble(read.table(igblast_annotation_path, sep = '\t', header = T))
dataset_name <- str_replace(basename(yaml_file_path),'.yaml','')
master_input_file <-  paste0(output_dir, 'igphyml_input_', dataset_name,'.tsv')
master_input_file_noCDR3 <-  paste0(output_dir,'igphyml_input_', dataset_name,'_noCDR3.tsv')
# Excluded clones (ones in which inferred FR/CDR region has a length that's not a multiple of 3)
excluded_clones_path <-  paste0(output_dir, dataset_name,'_clones_excluded_from_igphyml.csv')
clone_info_path <- paste0(output_dir, dataset_name,'_clone_info.csv')
master_input <- c()
clone_number <- 0
excluded_clones <- c()
clone_info <- c() # Tibble with summary information for each clone
# Read isotype information, if available
if(!is.null(isotype_info_path)){
isotype_info <- as_tibble(read.csv(isotype_info_path))
}else{
isotype_info <- NULL
}
parent_clone_dir <- paste0(output_dir, dataset_name, '_clones/')
dir.create(parent_clone_dir, showWarnings = F)
parent_igphyml_dir <- paste0(output_dir, dataset_name, '_igphyml/')
dir.create(parent_igphyml_dir, showWarnings = F)
clone <- yaml_object$events[[1]]
clone
print(paste('Processing clone',clone_number +1))
# Path to igphyml input files for this clone
igphyml_seq_path <- paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_igphyml.fasta')
igphyml_seq_path_noCDR3 <- paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_noCDR3_igphyml.fasta')
igphyml_partition_path <-  paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_part.txt')
igphyml_partition_path_noCDR3 <-  paste0(parent_igphyml_dir, dataset_name,'_clone_',
clone_number,'_noCDR3_part.txt')
# Clone fasta file (with 'N' characters removed but not processed for igphyml):
raw_clone_fasta_file <- paste0(parent_clone_dir, dataset_name,'_clone_',
clone_number,'.fasta')
aligned_cdr3_seqs_file <- paste0(parent_clone_dir, dataset_name,'_clone_',
clone_number,'_CDR3_alignment.fasta')
# Update tibble with general clone information
this_clone_info <- get_basic_clone_info(clone, isotype_info)
clone_info <- bind_rows(clone_info,
this_clone_info$info %>%
mutate(clone_id = clone_number)) %>%
select(clone_id, everything())
# Write raw clone seqs + germline (with 'N's removed but without processing for igphyml)
clone_seqs <- this_clone_info$seqs
write.fasta(as.list(clone_seqs), names = names(clone_seqs), file.out =  raw_clone_fasta_file)
# Write (aligned) CDR3 seqs
cdr3_seqs <- tolower(this_clone_info$cdr3_seqs)
write.fasta(as.list(cdr3_seqs), names = names(cdr3_seqs), file.out = aligned_cdr3_seqs_file)
# Constrain igphyml input to productive sequences
productive_seqs <- names(clone_seqs)[this_clone_info$is_productive]
aligned_cdr3_seqs_file
productive_seqs
length(productive_seqs)>1
# Check all clone seqs. in yaml file are also in presto annotation file.
stopifnot(all(names(clone_seqs)[names(clone_seqs) != 'NAIVE'] %in% igblast_annotation$SEQUENCE_ID))
# Initial processing of inferred naive sequence (remove 'N' characters at each end of germline sequence)
naive_seq <- clone$naive_seq
germline_Ns <- str_locate_all(naive_seq,'N+')[[1]]
n_start_Ns <- 0
terminal_Ns_start = nchar(naive_seq) +1
if(nrow(germline_Ns) > 0){
germline_start_Ns <- germline_Ns[1,]
if(germline_start_Ns[1] == 1){
n_start_Ns <- germline_start_Ns[2]
}
if(nrow(germline_Ns) > 1){
terminal_N_sites = germline_Ns[nrow(germline_Ns),]
if(terminal_N_sites[2] == nchar(naive_seq))
terminal_Ns_start = terminal_N_sites[2]
}
}
# Find naive sequence and IMGT-aligned observed sequences from this clone
naive_seq <- substr(naive_seq, n_start_Ns +1, terminal_Ns_start -1)
imgt_aligned_seqs <- left_join(tibble(SEQUENCE_ID = productive_seqs),
igblast_annotation %>% filter(SEQUENCE_ID %in% productive_seqs),
by = 'SEQUENCE_ID')
# Check all imgt-aligned regions have the same length (except possibly CDR3 and FR4)
lengths_match <- imgt_aligned_seqs %>% summarise_at(.vars =  vars(c("FWR1_IMGT","FWR2_IMGT", "FWR3_IMGT",
"CDR1_IMGT","CDR2_IMGT")),
.funs = function(x){return(length(unique(nchar(as.character(x)))))}) %>%
unlist() == 1
lengths_match
imgt_aligned_seqs
imgt_aligned_seqs <- left_join(tibble(SEQUENCE_ID = productive_seqs[productive_seqs != 'NAIVE']),
igblast_annotation %>% filter(SEQUENCE_ID %in% productive_seqs),
by = 'SEQUENCE_ID')
# Check all imgt-aligned regions have the same length (except possibly CDR3 and FR4)
lengths_match <- imgt_aligned_seqs %>% summarise_at(.vars =  vars(c("FWR1_IMGT","FWR2_IMGT", "FWR3_IMGT",
"CDR1_IMGT","CDR2_IMGT")),
.funs = function(x){return(length(unique(nchar(as.character(x)))))}) %>%
unlist() == 1
lengths_match
yaml_file_path
yaml_object
clone <- yaml_object[[45]]
yaml_object <- read_yaml(yaml_file_path)
igblast_annotation <- as_tibble(read.table(igblast_annotation_path, sep = '\t', header = T))
dataset_name <- str_replace(basename(yaml_file_path),'.yaml','')
master_input_file <-  paste0(output_dir, 'igphyml_input_', dataset_name,'.tsv')
master_input_file_noCDR3 <-  paste0(output_dir,'igphyml_input_', dataset_name,'_noCDR3.tsv')
# Excluded clones (ones in which inferred FR/CDR region has a length that's not a multiple of 3)
excluded_clones_path <-  paste0(output_dir, dataset_name,'_clones_excluded_from_igphyml.csv')
clone_info_path <- paste0(output_dir, dataset_name,'_clone_info.csv')
master_input <- c()
clone_number <- 0
excluded_clones <- c()
clone_info <- c() # Tibble with summary information for each clone
# Read isotype information, if available
if(!is.null(isotype_info_path)){
isotype_info <- as_tibble(read.csv(isotype_info_path))
}else{
isotype_info <- NULL
}
clone <- yaml_object$events[[45]]
yaml_object <- read_yaml(yaml_file_path)
igblast_annotation <- as_tibble(read.table(igblast_annotation_path, sep = '\t', header = T))
dataset_name <- str_replace(basename(yaml_file_path),'.yaml','')
master_input_file <-  paste0(output_dir, 'igphyml_input_', dataset_name,'.tsv')
master_input_file_noCDR3 <-  paste0(output_dir,'igphyml_input_', dataset_name,'_noCDR3.tsv')
# Excluded clones (ones in which inferred FR/CDR region has a length that's not a multiple of 3)
excluded_clones_path <-  paste0(output_dir, dataset_name,'_clones_excluded_from_igphyml.csv')
clone_info_path <- paste0(output_dir, dataset_name,'_clone_info.csv')
master_input <- c()
clone_number <- 0
excluded_clones <- c()
clone_info <- c() # Tibble with summary information for each clone
# Read isotype information, if available
if(!is.null(isotype_info_path)){
isotype_info <- as_tibble(read.csv(isotype_info_path))
}else{
isotype_info <- NULL
}
parent_clone_dir <- paste0(output_dir, dataset_name, '_clones/')
dir.create(parent_clone_dir, showWarnings = F)
parent_igphyml_dir <- paste0(output_dir, dataset_name, '_igphyml/')
dir.create(parent_igphyml_dir, showWarnings = F)
print(paste('Processing clone',clone_number +1))
# Path to igphyml input files for this clone
igphyml_seq_path <- paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_igphyml.fasta')
igphyml_seq_path_noCDR3 <- paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_noCDR3_igphyml.fasta')
igphyml_partition_path <-  paste0(parent_igphyml_dir, dataset_name,'_clone_', clone_number,'_part.txt')
igphyml_partition_path_noCDR3 <-  paste0(parent_igphyml_dir, dataset_name,'_clone_',
clone_number,'_noCDR3_part.txt')
# Update tibble with general clone information
this_clone_info <- get_basic_clone_info(clone, isotype_info)
this_clone_info$info
this_clone_info$seqs
this_clone_info$seqs
